use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Item, ItemConst, ItemEnum, ItemStruct, ItemType, Type};

fn rust_type_to_ts_type(rust_type: &Type) -> String {
    match rust_type {
        Type::Path(type_path) => {
            let path = type_path.path.clone();
            let segments = path.segments;
            let segment = segments.last().unwrap();
            let ident = segment.ident.to_string();

            match ident.as_str() {
                "u8" => "number".to_string(),
                "u16" => "number".to_string(),
                "u32" => "number".to_string(),
                "u64" => "number".to_string(),
                "i8" => "number".to_string(),
                "i16" => "number".to_string(),
                "i32" => "number".to_string(),
                "i64" => "number".to_string(),
                "f32" => "number".to_string(),
                "f64" => "number".to_string(),
                "bool" => "boolean".to_string(),
                "String" => "string".to_string(),
                _ => ident,
            }
        }
        _ => panic!("Unsupported type"),
    }
}

fn needs_import(rust_type: &Type) -> bool {
    match rust_type {
        Type::Path(type_path) => {
            let path = type_path.path.clone();
            let segments = path.segments;
            let segment = segments.last().unwrap();
            let ident = segment.ident.to_string();

            match ident.as_str() {
                "u8" => false,
                "u16" => false,
                "u32" => false,
                "u64" => false,
                "i8" => false,
                "i16" => false,
                "i32" => false,
                "i64" => false,
                "f32" => false,
                "f64" => false,
                "bool" => false,
                "String" => false,
                _ => true,
            }
        }
        _ => panic!("Unsupported type"),
    }
}

fn write_struct_ts_definition(item: &ItemStruct, writer: &mut impl std::io::Write) {
    writeln!(writer, "/* This file is automatically generated */").unwrap();
    writeln!(writer, "").unwrap();

    // Write imports for any types that need them.
    let mut imported_types = Vec::new();

    for field in &item.fields {
        let ts_type = rust_type_to_ts_type(&field.ty);

        if needs_import(&field.ty) && !imported_types.contains(&ts_type) {
            writeln!(writer, "import type {{ {0} }} from \"./{0}\";", ts_type).unwrap();
            imported_types.push(ts_type);
        }
    }

    writeln!(writer, "").unwrap();

    // Structs are mapped to interfaces in TypeScript.
    writeln!(writer, "export interface {} {{", item.ident).unwrap();

    for field in &item.fields {
        writeln!(
            writer,
            "\t{}: {}",
            field.ident.clone().unwrap(),
            rust_type_to_ts_type(&field.ty)
        )
        .unwrap();
    }

    writeln!(writer, "}}").unwrap();
    writeln!(writer, "").unwrap();
}

fn write_enum_ts_definition(item: &ItemEnum, writer: &mut impl std::io::Write) {
    writeln!(writer, "/* This file is automatically generated */").unwrap();
    writeln!(writer, "").unwrap();

    // Write imports for any types that need them.
    let mut imported_types = Vec::new();

    for variant in &item.variants {
        for field in &variant.fields {
            let ts_type = rust_type_to_ts_type(&field.ty);

            if needs_import(&field.ty) && !imported_types.contains(&ts_type) {
                writeln!(writer, "import type {{ {0} }} from \"./{0}\";", ts_type).unwrap();
                imported_types.push(ts_type);
            }
        }
    }

    writeln!(writer, "").unwrap();

    // Enums values are each mapped to a different struct type and then unioned together
    // in a single type.
    for variant in &item.variants {
        writeln!(writer, "export type {}_{} = {{", item.ident, variant.ident).unwrap();

        writeln!(writer, "\t{}: {{", variant.ident).unwrap();

        for field in &variant.fields {
            writeln!(
                writer,
                "\t\t{}: {}",
                field.ident.clone().unwrap(),
                rust_type_to_ts_type(&field.ty)
            )
            .unwrap();
        }

        writeln!(writer, "\t}}").unwrap();
        writeln!(writer, "}}").unwrap();
        writeln!(writer, "").unwrap();
    }

    writeln!(writer, "export type {} =", item.ident).unwrap();

    for variant in &item.variants {
        writeln!(writer, "\t|  {}_{}", item.ident, variant.ident).unwrap();
    }

    writeln!(writer, "").unwrap();

    // Write type guard methods for each variant.
    for variant in &item.variants {
        writeln!(
            writer,
            "export function is{0}_{1}(value: {0}): value is {0}_{1} {{",
            item.ident, variant.ident
        )
        .unwrap();
        writeln!(writer, "\treturn \"{}\" in value;", variant.ident).unwrap();
        writeln!(writer, "}}").unwrap();
        writeln!(writer, "").unwrap();
    }
}

fn write_type_alias_ts_definition(item: &ItemType, writer: &mut impl std::io::Write) {
    writeln!(writer, "/* This file is automatically generated */").unwrap();
    writeln!(writer, "").unwrap();

    writeln!(
        writer,
        "export type {} = {}",
        item.ident,
        rust_type_to_ts_type(&item.ty)
    )
    .unwrap();
    writeln!(writer, "").unwrap();
}

fn write_const_ts_definition(item: &ItemConst, writer: &mut impl std::io::Write) {
    writeln!(writer, "/* This file is automatically generated */").unwrap();
    writeln!(writer, "").unwrap();

    let expr = &item.expr;

    writeln!(
        writer,
        "export const {}: {} = {};",
        item.ident,
        rust_type_to_ts_type(&item.ty),
        quote!(#expr)
    )
    .unwrap();
    writeln!(writer, "").unwrap();
}

/// This attribute automatically generates TypeScript definitions for Rust types.
/// It is intended to be used for types that are defined in Rust but need to be
/// also used in TypeScript.
///
/// Generated types are placed in the `src/lib/types` directory.
#[proc_macro_attribute]
pub fn export_ts(_attr: TokenStream, input: TokenStream) -> TokenStream {
    let input_clone = input.clone();
    let item = parse_macro_input!(input_clone as Item);

    // Create directory if it doesn't exist.
    let def_folder = "../src/lib/types";
    std::fs::create_dir_all(def_folder).unwrap();

    match item {
        Item::Struct(item) => {
            let ts_def_filename = format!("{}/{}.ts", def_folder, item.ident);
            let mut file = std::fs::File::create(ts_def_filename).unwrap();
            write_struct_ts_definition(&item, &mut file);
        }
        Item::Enum(item) => {
            let ts_def_filename = format!("{}/{}.ts", def_folder, item.ident);
            let mut file = std::fs::File::create(ts_def_filename).unwrap();
            write_enum_ts_definition(&item, &mut file);
        }
        Item::Type(item) => {
            let ts_def_filename = format!("{}/{}.ts", def_folder, item.ident);
            let mut file = std::fs::File::create(ts_def_filename).unwrap();
            write_type_alias_ts_definition(&item, &mut file);
        }
        Item::Const(item) => {
            let ts_def_filename = format!("{}/{}.ts", def_folder, item.ident);
            let mut file = std::fs::File::create(ts_def_filename).unwrap();
            write_const_ts_definition(&item, &mut file);
        }
        _ => {
            syn::Error::new_spanned(
                item,
                "ts_export only supports structs, enums, type aliases, and constants",
            )
            .to_compile_error();
        }
    };

    input
}
